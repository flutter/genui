# Usage of `flutter_genui`

This guidance explains how to quickly get started with the
[`flutter_genui`](https://pub.dev/packages/flutter_genui) package.

## Key components

- **`UiAgent`**: The main entry point of the package. It manages the
  conversation with the LLM, handles UI state, and orchestrates the interaction
  between the app, its UI, and the AI.

- **`AiClient`**: A client that manages communication with your LLM. The package
  includes an (optional) `FirebaseAiClient` to communicate with Google's Gemini
  models (using Firebase AI Logic), and you can create your own subclasses for
  other models or LLM libraries.

- **`GenUiSurface`**: A Flutter widget that displays UI generated by the agent.
  It listens for updates from `UiAgent` and dynamically renders the generated
  UI.

- **`Catalog`**: A catalog of Flutter widgets that the AI is allowed to
  generate. For each widget, you define a name, a schema that describes the data
  needed by the widget, and a builder function. The built-in `CoreCatalogItems`
  include widgets for rendering text, markdown, and images.

- **`GenUiManager`**: The core state manager for generated UI. You won't often
  interact directly with this class, but it's responsible for managing the flow
  of information and events between the agent and your UI.

## Add `flutter_genui` to your app

Use the following instructions to add `flutter_genui` to your Flutter app. The
code examples show how to perform the instructions on a brand new app created by
running `flutter create`.

### 1. Configure your agent provider

`flutter_genui` can connect to a variety of agent providers. Choose the section
below for your preferred provider.

#### Configure Firebase AI Logic

To use the built-in `FirebaseAiClient` to connect to Gemini via Firebase AI
Logic, follow these instructions:

1. [Create a new Firebase project](https://support.google.com/appsheet/answer/10104995)
   using the Firebase Console.
2. [Enable the Gemini API](https://firebase.google.com/docs/gemini-in-firebase/set-up-gemini)
   for that project.
3. Follow the first three steps in
   [Firebase's Flutter Setup guide](https://firebase.google.com/docs/flutter/setup)
   to add Firebase to your app.
4. In `pubspec.yaml`, add `flutter_genui` and `flutter_genui_firebase_ai` to the
   `dependencies` section. As of this writing, it's best to use pub's git
   dependency to refer directly to this project's source.

   ```yaml
   dependencies:
     # ...
     flutter_genui:
       git:
         url: https://github.com/flutter/genui.git
         path: packages/flutter_genui
         ref: 6e472cf0f7416c31a1de6af9a0d1b4cc37188989
     flutter_genui_firebase_ai:
       git:
         url: https://github.com/flutter/genui.git
         path: packages/flutter_genui_firebase_ai
   ```

5. In your app's `main` method, ensure that the widget bindings are initialized,
   and then initialize Firebase.

   ```dart
   void main() async {
     WidgetsFlutterBinding.ensureInitialized();
     await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
     runApp(const MyApp());
   }
   ```

#### Configure another agent provider

To use `flutter_genui` with another agent provider, you need to follow that
provider's instructions to configure your app, and then create your own subclass
of `AiClient` to connect to that provider. Use `FirebaseAiClient` as an example
of how to do so.

### 2. Create the connection to an agent

If you build your Flutter project for iOS or macOS, add this key to your
`{ios,macos}/Runner/*.entitlements` file(s) to enable outbound network
requests:

```xml
<dict>
...
<key>com.apple.security.network.client</key>
<true/>
</dict>
```

Next, use the following instructions to connect your app to your chosen agent
provider.

1. Create a `GenUiManager`, and provide it with the catalog of widgets you want
   to make available to the agent.
2. Create an `AiClient`, and provide it with a system instruction and a set of
   tools (functions you want the agent to be able to invoke). You should always
   include those provided by `GenUiManager`, but feel free to include others.
3. Create a `UiAgent` using the instances of `AiClient` and `GenUiManager`. Your
   app will primarily interact with this object to get things done.

   For example:

   ```dart
   class _MyHomePageState extends State<MyHomePage> {
     late final GenUiManager _genUiManager;
     late final UiAgent _uiAgent;

     @override
     void initState() {
       super.initState();

       // Create a GenUiManager with a widget catalog.
       // The CoreCatalogItems contain basic widgets for text, markdown, and images.
       _genUiManager = GenUiManager(catalog: CoreCatalogItems.asCatalog());

       // Create an AiClient to communicate with the LLM.
       // Provide system instructions and the tools from the GenUiManager.
       final aiClient = FirebaseAiClient(
         systemInstruction: '''
           You are an expert in creating funny riddles. Every time I give you a word,
           you should generate UI that displays one new riddle related to that word.
           Each riddle should have both a question and an answer.
           ''',
         tools: _genUiManager.getTools(),
       );

       // Create the UiAgent to orchestrate everything.
       _uiAgent = UiAgent(
         genUiManager: _genUiManager,
         aiClient: aiClient,
         onSurfaceAdded: _onSurfaceAdded, // Added in the next step.
         onSurfaceDeleted: _onSurfaceDeleted, // Added in the next step.
       );
     }

     @override
     void dispose() {
       _textController.dispose();
       _uiAgent.dispose();
       _genUiManager.dispose();
       super.dispose();
     }
   }
   ```

### 3. Send messages and display the agent's responses

Send a message to the agent using the `sendRequest` method in the `UiAgent`
class.

To receive and display generated UI:

1. Use `UiAgent`'s callbacks to track the addition and removal of UI surfaces as
   they are generated. These events include a "surface ID" for each surface.
2. Build a `GenUiSurface` widget for each active surface using the surface IDs
   received in the previous step.

   For example:

   ```dart
   class _MyHomePageState extends State<MyHomePage> {

     // ...

     final _textController = TextEditingController();
     final _surfaceIds = <String>[];

     // Send a message containing the user's text to the agent.
     void _sendMessage(String text) {
       if (text.trim().isEmpty) return;
       uiAgent.sendRequest(UserMessage.text(text));
     }

     // A callback invoked by the [UiAgent] when a new UI surface is generated.
     // Here, the ID is stored so the build method can create a GenUiSurface to
     // display it.
     void _onSurfaceAdded(SurfaceAdded update) {
       setState(() {
         _surfaceIds.add(update.surfaceId);
       });
     }

     // A callback invoked by UiAgent when a UI surface is removed.
     void _onSurfaceDeleted(SurfaceRemoved update) {
       setState(() {
         _surfaceIds.remove(update.surfaceId);
       });
     }

     @override
     Widget build(BuildContext context) {
       return Scaffold(
         appBar: AppBar(
           backgroundColor: Theme.of(context).colorScheme.inversePrimary,
           title: Text(widget.title),
         ),
         body: Column(
           children: [
             Expanded(
               child: ListView.builder(
                 itemCount: _surfaceIds.length,
                 itemBuilder: (context, index) {
                   // For each surface, create a GenUiSurface to display it.
                   final id = _surfaceIds[index];
                   return GenUiSurface(host: uiAgent.host, surfaceId: id);
                 },
               ),
             ),
             SafeArea(
               child: Padding(
                 padding: const EdgeInsets.symmetric(horizontal: 16.0),
                 child: Row(
                   children: [
                     Expanded(
                       child: TextField(
                         controller: _textController,
                         decoration: const InputDecoration(
                           hintText: 'Enter a message',
                         ),
                       ),
                     ),
                     const SizedBox(width: 16),
                     ElevatedButton(
                       onPressed: () {
                         // Send the user's text to the agent.
                         _sendMessage(_textController.text);
                         _textController.clear();
                       },
                       child: const Text('Send'),
                     ),
                   ],
                 ),
               ),
             ),
           ],
         ),
       );
     }
   }
   ```

## 4. [Optional] Add your own widgets to the catalog

In addition to using the catalog of widgets in `CoreCatalogItems`, you can
create custom widgets for the agent to generate. Use the following
instructions.

#### Import `json_schema_builder`

Add the `json_schema_builder` package as a dependency in `pubspec.yaml`. Use the
same commit reference as the one for `flutter_genui`.

```yaml
dependencies:
  # ...
  json_schema_builder:
    git:
      url: https://github.com/flutter/genui.git
      path: packages/json_schema_builder
      ref: 6e472cf0f7416c31a1de6af9a0d1b4cc37188989
```

#### Create the new widget's schema

Each catalog item needs a schema that defines the data required to populate it.
Using the `json_schema_builder` package, define one for the new widget.

```dart
import 'package:json_schema_builder/json_schema_builder.dart';
import 'package:flutter/material.dart';
import 'package:flutter_genui/flutter_genui.dart';

final _schema = S.object(
  properties: {
    'question': S.string(description: 'The question part of a riddle.'),
    'answer': S.string(description: 'The answer part of a riddle.'),
  },
  required: ['question', 'answer'],
);
```

#### Create a `CatalogItem`

Each `CatalogItem` represents a type of widget that the agent is allowed to
generate. To do that, combines a name, a schema, and a builder function that
produces the widgets that compose the generated UI.

```dart
final riddleCard = CatalogItem(
  name: 'RiddleCard',
  dataSchema: _schema,
  widgetBuilder:
      ({
        required data,
        required id,
        required buildChild,
        required dispatchEvent,
        required context,
        required dataContext,
      }) {
        final json = data as Map<String, Object?>;
        final question = json['question'] as String;
        final answer = json['answer'] as String;

        return Container(
          constraints: const BoxConstraints(maxWidth: 400),
          decoration: BoxDecoration(border: Border.all()),
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(question, style: Theme.of(context).textTheme.headlineMedium),
              const SizedBox(height: 8.0),
              Text(answer, style: Theme.of(context).textTheme.headlineSmall),
            ],
          ),
        );
      },
);
```

#### Add the `CatalogItem` to the catalog

Include your catalog items when instantiating `GenUiManager`.

```dart
final genUiManager = GenUiManager(
  catalog: CoreCatalogItems.asCatalog().copyWith([riddleCard]),
);
```

#### Update the system instruction to use the new widget

In order to make sure the agent knows to use your new widget, use the system
instruction to explicitly tell it how and when to do so. Provide the name from
the CatalogItem when you do.

```dart
final aiClient = FirebaseAiClient(
  systemInstruction: '''
      You are an expert in creating funny riddles. Every time I give you a word,
      you should generate a RiddleCard that displays one new riddle related to that word.
      Each riddle should have both a question and an answer.
      ''',
  tools: genUiManager.getTools(),
);
```

## Data Model and Data Binding

A core concept in `flutter_genui` is the **`DataModel`**, a centralized, observable store for all dynamic UI state. Instead of widgets managing their own state, their state is stored in the `DataModel`.

Widgets are "bound" to data in this model. When data in the model changes, only the widgets that depend on that specific piece of data are rebuilt. This is achieved through a `DataContext` object that is passed to each widget's builder function.

### Binding to the Data Model

To bind a widget's property to the data model, you use a special JSON object in the data sent from the AI. This object can contain either a `literalString` (for static values) or a `path` (to bind to a value in the data model).

For example, to display a user's name in a `Text` widget, the AI would generate:

```json
{
  "id": "user_name_text",
  "widget": {
    "Text": {
      "text": { "path": "/user/name" }
    }
  }
}
```

And the `DataModel` would contain:

```json
{
  "user": {
    "name": "Alice"
  }
}
```

### Updating the Data Model

Input widgets, like `TextField`, update the `DataModel` directly. When the user types in a text field that is bound to `/user/name`, the `DataModel` is updated, and any other widgets bound to that same path will automatically rebuild to show the new value.

This reactive data flow simplifies state management and creates a powerful, high-bandwidth interaction loop between the user, the UI, and the AI.

## Next steps

Check out the [examples](../../examples) included in this repo! The
[travel app](../../examples/travel_app) shows how to define your own widget
`Catalog` that the agent can use to generate domain-specific UI.

If something is unclear or missing, please
[create an issue](https://github.com/flutter/genui/issues/new/choose).

## System instructions

The `flutter_genui` package gives the LLM a set of tools it can use to generate
UI. To get the LLM to use these tools, the `systemInstruction` provided to
`AiClient` must explicitly tell it to do so. This is why the previous example
includes a system instruction for the agent with the line "Every time I give
you a word, you should generate UI that displays one new riddle...".

## Troubleshooting / FAQ

### How can I configure logging?

To observe communication between your app and the agent, enable logging in your
`main` method.

```dart
import 'package:logging/logging.dart';

final logger = configureGenUiLogging(level: Level.ALL);

void main() async {
  logger.onRecord.listen((record) {
    debugPrint('${record.loggerName}: ${record.message}');
  });

  // Additional initialization of bindings and Firebase.
}
```

### I'm getting errors about my minimum macOS/iOS version.

Firebase has a
[minimum version requirement](https://firebase.google.com/support/release-notes/ios)
for Apple's platforms, which might be higher than Flutter's default. Check your
`Podfile` (for iOS) and `CMakeLists.txt` (for macOS) to ensure you're targeting
a version that meets or exceeds Firebase's requirements.