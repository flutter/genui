# Requirements

The JSON schema represents a UI, composed of a hierarchy of components, which reference each other via ID. There is a root component, a list of components, a style, and a shared data model for components to use.


## JSON schema format



*   DO NOT use $ref and $def - instead inline the appropriate schema contents
*   DO NOT use “const”
*   DO NOT use $id or $schema fields at the top of the schema - just skip them.
*   Include description fields throughout the JSON to explain what each field is for.
*   Try to keep the schema as shallow as possible
*   Conform to the JSON schema limitations of all supported LLMs, including: 
    *   OpenAI: see https://learn.microsoft.com/en-us/azure/ai-foundry/openai/how-to/structured-outputs?tabs=python-secure%2Cdotnet-entra-id&pivots=programming-language-csharp#supported-schemas-and-limitations
    *   Google - see `https://ai.google.dev/api/caching#Schema`


## Concepts

The schema will refer to a number of concepts defined here. These concepts will not necessarily be represented by fields or subschemas directly, but they’re useful to provide a shared language.



*   Component in Catalog - a type of component that is supported e.g. Heading, AudioPlayer etc. Each Component has a name in upper CamelCase, and an associated object schema which defines the properties used to populate that specific type of component.
*   Layout node - A specific instance of a Component Type. Each node has a unique id, a type, and the necessary data for that type.
*   Layout - A renderable layout which contains a hierarchy of Component instances, referring to each other by ID. The layout defines a ‘root’ component ID and then a flat list of components.
*   LayoutNodeRef - a reference to another node, which is a child.
*   LayoutNodeListRef - reference to a list of node. This can be be \*either\* an explicit list of LayoutNodeRef \*or\* a template LayoutNode and a DataBinding reference to a list of data, where the template can refer to local paths within specific data items in the list.


## Layout Node Schema (LayoutNode)

A `LayoutNode` message is a JSON object with the following keys:



*   `id`: A required, unique string that identifies this specific widget instance.
*   `type`: A string that must match a widget type name in the `ComponentCatalog`.
*   `properties`: An object containing the properties for this widget. A property's value can be a static literal (string, number, boolean, etc.) or a binding object.
*   

Nodes can also can refer to other nodes, as;



*   Single references e.g. ‘child’. These property names should end in the suffix ‘Child’ and they should be string type to refer to other nodes by ID
*   lists of references e.g. “children”. These should follow the LayoutNodeListRef guidance above. The property should end in the suffix ‘children’.


## Data Binding with Transformations

The `properties` map within a `LayoutNode` forges the connection between layout and state. A property is bound to state if its value is an object containing a `"$bind"` key.


```
// General structure of a binding object
"properties": {
  "widgetProperty": {
    "$bind": "/path/to/data", // Path to data in the state object
    // Optional transformers below
    "format": "Value is: {}"
  }
}
```


A widget property can be supplied by any of the following:

 - A reference to the global data model, starting with a leading "/"

 - A reference to a local data model item, starting without a leading "/"

 - A literal value

Alternatively, a property like widgetProperty can refer to inline literal data e.g. a string, number, boolean, object or array. This could be represented with some “literal” type.


## Styles

There is a concept of style which affects an entire layout. The style has the following attributes:



*   primaryColor
*   logo


## Action

Each Element in the Catalog can also support actions which need to be handled e.g. a button has an onTap action. The action is typically sent to an LLM, and so the event needs to be associated with context from surrounding elements which may be needed.

This is achieved by associating “context” items with the event in a Layout definition. The context items include:



*   Static information 
*   References to the data model
*   References to layoutNodes with relevant state


## DataModel

There is an arbitrary global JSON “data model” which LayoutNodes can refer to to get data. This can be supplied as part of the layout definition at the root level.


## UI elements catalog


<table>
  <tr>
   <td><strong>Priority</strong>
   </td>
   <td><strong>Element name</strong>
   </td>
   <td><strong>Fields</strong>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td colspan="4"><strong>Primitives</strong>
   </td>
  </tr>
  <tr>
   <td>P0
   </td>
   <td>Heading
   </td>
   <td>text, level
   </td>
   <td>Levels would be 1, 2, 3, 4, or 5 to indicate the importance, similarly to how Docs and the web indicate heading 1 through 5.
   </td>
  </tr>
  <tr>
   <td>P0
   </td>
   <td>Text
   </td>
   <td>text
   </td>
   <td>Should support markdown. We use markdown here instead of having font size control, or special widgets for headings or anything like that.
   </td>
  </tr>
  <tr>
   <td>P0
   </td>
   <td>Image
   </td>
   <td>fit, max_width, max_height, aspect_ratio, url
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>P0
   </td>
   <td>Video
   </td>
   <td>max_width, max_height, aspect_ratio, url
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>P1
   </td>
   <td>AudioPlayer
   </td>
   <td>description, url
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td colspan="4"><strong>Layout</strong>
   </td>
  </tr>
  <tr>
   <td>P0
   </td>
   <td>Row
   </td>
   <td>children, distribution, alignment
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>P0
   </td>
   <td>Column
   </td>
   <td>children, distribution, alignment
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>P0
   </td>
   <td>List
   </td>
   <td>direction, children, alignment
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>P0
   </td>
   <td>Card
   </td>
   <td>child
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>P2
   </td>
   <td>Tabs
   </td>
   <td>A list of objects each with a child and title string
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>P2
   </td>
   <td>Divider
   </td>
   <td><ul>

<li>Axis: horizontal or vertical, color, thickness</li></ul>

   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>P2
   </td>
   <td>Carousel
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>P2
   </td>
   <td>Container
   </td>
   <td><ul>

<li>Alignment
<li>Padding
<li>MaxWidth ?
<li>MaxHeight ?</li></ul>

   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>P2
   </td>
   <td>Modal
   </td>
   <td><ul>

<li>entryPointChild - the widget that is shown directly in the main view
<li>contentChild - the content shown in the dialog</li></ul>

   </td>
   <td>Contract: the host should display the contentChild over the top of other content, giving it as much screen real estate as possible. This could look like a dialog, bottom sheet etc.
   </td>
  </tr>
  <tr>
   <td colspan="4"><strong>Form Input types</strong>
   </td>
  </tr>
  <tr>
   <td>P0
   </td>
   <td>Button
   </td>
   <td>label, action
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>P1
   </td>
   <td>CheckBox
   </td>
   <td>label, value (when checked)
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>P0
   </td>
   <td>TextField
   </td>
   <td>description, type, validationRegexp
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>P1
   </td>
   <td>DateTimeInput
   </td>
   <td>enableDate enableTime outputFormat
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>P1
   </td>
   <td>MultipleChoice
   </td>
   <td><ul>

<li>options: List&lt;Object>
<li>maxAllowedSelections: number
<li>initialSelections: List&lt;String></li></ul>

   </td>
   <td>If options.length == 1: Check box
<p>
Else if maxAllowedSelections == 1: Radio buttons
<p>
Else check boxes
<p>
options is a list of objects with “label” and “value” members.
   </td>
  </tr>
  <tr>
   <td>P2
   </td>
   <td>Slider
   </td>
   <td>min_value, max_value
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td colspan="4"><strong>Agent-specific</strong> \
Maybe there are some elements which are not in all UI frameworks but would be specifically valuable to A2A
   </td>
  </tr>
  <tr>
   <td>P1
   </td>
   <td>Form
   </td>
   <td>child: element
<p>
submitButtonTitle: string \
action: action
   </td>
   <td>A card-like collection of elements with an associated submit button that calls some URL. It shows a loading spinner while the request is pending, then success/failure after it completes. If you try to implement this with just raw fields and buttons, it’s not really possible because you need some amount of logic to get the loading state to work properly. The form concept simplifies this. \
 \
See <a href="https://docs.google.com/document/d/1Ow204FjYzunj_pjDVApjxbcQJ2sieLDks6KPekl3JQk/edit?tab=t.0#heading=h.mig471lz3pd8">Agentspace Action UI As A Rich UI Use Case</a>
   </td>
  </tr>
  <tr>
   <td colspan="4"><strong>Other</strong>
   </td>
  </tr>
  <tr>
   <td>P2
   </td>
   <td>Loading spinner
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
</table>

