# `genui_client` API Review and Suggestions (Dual-Layer API)

This document provides a comprehensive review of the `genui_client` package, updated to reflect the design goal of providing a **dual-layer API**. This approach aims to offer a simple, high-level facade for common use cases, alongside a more powerful, customizable lower-level API for advanced users.

The suggestions below are aimed at improving the developer experience (DX), increasing robustness, and structuring the package to successfully serve both audiences.

## High-Level Architectural Suggestions

### 1. Formalize the Dual-Layer API with Library Exports

The most effective way to create a dual-layer API in Dart is to control what is exported from different library files. This makes the separation clear and intentional.

**Suggestion:**

- **Create a "Simple" Entry Point (`genui_client.dart`):** This should be the default import for 90% of users. It should export the high-level facade and the essential widgets and models needed to get started quickly.

  - `UiAgent` (The simple facade)
  - `GenUiSurface`, `GenUiChat`, `ConversationWidget`
  - Core data models (`ChatMessage`, `UiDefinition`, `Catalog`, etc.)

- **Create an "Advanced" Entry Point (`advanced_api.dart`):** This library should export the lower-level building blocks for users who need to customize the client's behavior or integrate it into their own state management solutions.
  - `GenUiManager`
  - `GenUIClient`
  - The `SurfaceBuilder` interface
  - `UiEvent` and related event classes
  - All other components needed for custom implementations.

Your documentation should then clearly guide users to the appropriate entry point based on their needs.

### 2. Use Dependency Injection to Empower Both APIs

Dependency Injection (DI) is the key to making the dual-layer API work. It allows the simple facade to be easy to use while enabling the advanced API to be flexible.

**Suggestion:**

- **Use a Single, Flexible Constructor for `UiAgent`**: Instead of multiple constructors, use a single constructor with optional, named parameters that default to new instances of its dependencies. This is a common and idiomatic pattern in Dart that cleanly serves both API layers.

  - **Simple API Usage:** A user can call `UiAgent()` without arguments to get a default instance.

    ```dart
    // Simple, "out-of-the-box" usage
    final agent = UiAgent();
    ```

  - **Advanced API / Testing Usage:** An advanced user can provide their own custom or mocked dependencies for any of the parameters they choose.

    ```dart
    // Advanced usage, providing a custom client for testing
    final mockClient = MockGenUIClient();
    final agent = UiAgent(client: mockClient);
    ```

### 3. Clarify State Management Roles

The dual-layer API clarifies the roles of the different classes in managing state.

**Suggestion:**

- **`UiAgent` as the Simple State Solution:** For users of the simple API, `UiAgent` should act as the single source of truth and the primary state management solution. It should expose state via `ValueNotifier` or `Stream` (e.g., `ValueListenable<bool> get isProcessing`).
- **`GenUiManager` as the Advanced State Container:** For advanced users who bypass `UiAgent`, `GenUiManager` serves as a clean, focused state container for UI surfaces. Its design is already well-suited for this, exposing state via `ValueNotifier` and `Stream`.

## Data Model Improvements (Benefits All Users)

These suggestions improve the core robustness of the package for both simple and advanced users.

### 1. Enforce Immutability with `freezed`

The current data models are standard classes. Using `freezed` will prevent a wide range of potential bugs related to mutable state.

**Suggestion:**

- Refactor all data models (`ChatMessage`, `UiDefinition`, `UiEvent`, etc.) using the [`freezed`](https://pub.dev/packages/freezed) package.
- **Benefits:** True immutability, value equality (`==`/`hashCode`), `copyWith` methods, exhaustive pattern matching, and seamless JSON serialization.

### 2. Improve Error Handling and Serialization in `GenUIClient`

The `GenUIClient` uses generic `Exception`s and manual JSON parsing.

**Suggestion:**

- **Create Custom Exceptions:** Define a specific `GenUIClientException` to allow for more granular `try/catch` logic by the caller.
- **Robust Deserialization:** Use `fromJson` constructors (generated by `freezed` and `json_serializable`) within `generateUI` to safely parse incoming stream chunks. This prevents runtime errors from unexpected or malformed JSON from the server.

## Component-Specific Suggestions

### `UiAgent`

- **Use Streams for Events:** Instead of `ValueChanged` callbacks like `onSurfaceAdded`, expose a `Stream<GenUiUpdate>`. This is more idiomatic and flexible for consumers.
- **Expose Conversation History:** Provide a public, read-only view of the conversation history, e.g., `ValueListenable<List<ChatMessage>> get conversation`.

### `GenUiChat` and `ConversationWidget`

- These widgets should be refactored to be "dumb" presentation components. They should take their state (like the list of messages) directly as parameters and use callbacks for events, rather than relying on a `GenUiChatController` that duplicates state logic. For the simple API, a parent widget would listen to the `UiAgent` and pass the state down.

## Code-Level & DX Improvements

- **Add `dartdoc` Comments:** All public APIs, especially for the advanced layer, should have comprehensive `dartdoc` comments.
- **Use `final`:** Ensure all local variables and fields that are not reassigned are marked as `final`.
- **Logging:** Continue using the `logging` package, ensuring messages provide clear context for debugging, and that all places that could provide useful debugging information have logging.
- **Clean Up Exports:** As mentioned in point #1, carefully curate the exports from the main `genui_client.dart` file to present a clean and focused simple API.
